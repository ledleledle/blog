[{"content":"Intro Bagi user maniak Windows atau yang cuma terpaksa pakai Windows. Mungkin dari kalian ada yang bingung untuk menginstall docker tanpa desktopnya karena sekarang docker desktop jadi suatu hal yang berbayar, then I will show you.\nRequirements  WSL 2  Check apakah WSL sudah diinstall 1  wsl -l -v   Jika sudah maka kita akan ditunjukkan versinya.\nInstall WSL Jika belum kita bisa install lewat Powershell dengan command berikut. Pilih distributor yang tersedia, disini saya pakai Ubuntu.\n1  wsl --install -d Ubuntu   Jika sudah, kita akan diminta untuk melakukan restart pada device kita.\n1 2 3 4  Windows Subsystem for Linux has been installed. Installing: Ubuntu Ubuntu has been installed. The requested operation is successful. Changes will not be effective until the system is rebooted.   Create User Ini wajib saat kalian menggunakan WSL untuk pertama kali. Membuat user untuk akses WSL kalian.\n1 2 3 4  Installing, this may take a few minutes... Please create a default UNIX user account. The username does not need to match your Windows username. For more information visit: https://aka.ms/wslusers Enter new UNIX username:   Install Docker Install Docker seperti biasa (kayak di Ubuntu). Bisa dicek disini Docs Docker Install jika kalian menggunakan distro lain.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # Add Docker\u0026#39;s official GPG key: sudo apt update sudo apt -y install ca-certificates curl sudo install -m 0755 -d /etc/apt/keyrings sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc sudo chmod a+r /etc/apt/keyrings/docker.asc # Add the repository to Apt sources: echo \\  \u0026#34;deb [arch=$(dpkg --print-architecture)signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\ $(. /etc/os-release \u0026amp;\u0026amp; echo \u0026#34;$VERSION_CODENAME\u0026#34;)stable\u0026#34; | \\  sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null sudo apt-get update # Install Docker sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin   Add user to docker group Lalu tambahkan user kalian ke dalam group docker, ini ditujukan agar user kita bisa mengakses docker tanpa harus menggunakan user root.\n1 2  sudo groupadd docker sudo usermod -aG docker $USER   Setelah itu tutup dan buka kembali WSL kalian.\nAkses di Powershell Kita bisa menggunakan docker tanpa harus membuka WSL dengan command berikut.\n1 2  wsl docker ps wsl docker images   Tapi dengan wsl didepan tiap commandnya pasti sangat mengganggu kita, maka dari itu kita harus membuat alias agar docker lebih mudah untuk diakses.\nMembuat Alias Cari dulu PowerShell Profile. Lalu edit/buat baru file Profilenya.\n1 2 3 4 5  echo $PROFILE # Output: # C:\\Users\\UserGanteng\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1 notepad $PROFILE   Lalu copy command berikut.\n1 2 3 4 5  Function Start-WslDocker { wsl docker $args } Set-Alias -Name docker -Value Start-WslDocker   Simpan lalu restart PowerShell. Lalu coba ketikkan command docker tanpa wsl didepannya.\n1  docker ps   Semoga kalian terbantu.\nReferences  https://canonical-ubuntu-wsl.readthedocs-hosted.com/en/latest/guides/install-ubuntu-wsl2/ https://docs.docker.com/engine/install/ubuntu https://blog.sixeyed.com/your-must-have-powershell-aliases-for-docker/  ","date":"2022-02-20T21:18:22+07:00","image":"https://blog.leonprasetya.my.id/p/install-docker-tanpa-docker-desktop-di-windows-10/11/index_hu54fb7902636bf3b40598986d7299de43_153295_120x120_fill_box_smart1_3.png","permalink":"https://blog.leonprasetya.my.id/p/install-docker-tanpa-docker-desktop-di-windows-10/11/","title":"Install Docker tanpa Docker Desktop di Windows 10/11"},{"content":"FYI  Saya sedang membuat serial untuk pembelajaran KONG pada blog ini. Kita menggunakan KONG Community Edition. Untuk mempermudah praktek, kita akan menggunakan KONGA  Serial  Instalasi Kong Api Gateway \u0026amp; KONGA dengan Docker Compose Pembahasan Services dan Routes pada Kong Api Gateway Implementasi JWT Pada KONG \u0026lt;\u0026ndash; Kita disini  Intro Kita akan melanjutkan pembahasan KONG dari yang kemarin, kemarin maksud saya 2 bulan yang lalu wkwk. Jadi pada pembahasan sebelumnya kita telah mengetahui tentang Service dan Routes. Pada pembahasan kali ini pahami dulu yang namanya Consumer dan Plugins.\n Plugins adalah tools yang disediakan atau bisa dibuat sendiri, untuk mempermudah user dalam mengimplementasi fungsionalitas yang diinginkan. Misal disini kita akan menggunakan plugin JWT dalam praktek kali ini. Consumer berperan sebagai pemegang kunci autentikasi. Jadi misal kita punya plugin autentikasi (seperti JWT, Key Auth, dll) yang terpasang pada service/route, plugin autentikasi disini bisa diibaratkan sebagai lubang kunci dan Consumer adalah sang kunci untuk mengakses API yang memiliki autentikasi. CMIIW.  Pembahasan Setelah mengerti tentang Plugin dan Consumer, kita akan lanjut untuk mengimplementasikan autentikasi JWT pada API kita. Karena sebelumnya kita telah membahas tentang Service dan Route, kita akan membahasnya sedikit saja disini.\nJadi pertama, buat service dan routenya terlebih dahulu.\nSelanjutnya yaitu mengaktifkan Plugin JWT. Kita bisa mengaktifkannya secara:\n Scoped: terpusat pada salah satu service atau route Global: plugin akan diaktifkan pada semua service dan route  Namun disini, kita akan memasangnya secara Scoped yaitu pada Service. Masuk ke Service \u0026gt; Plugins \u0026gt; Add Plugin. Lalu pilih JWT.\nPada Plugin ini yang wajib kita isi yaitu:\n consumer (nope): tidak boleh diisi, atau KONGA akan menampilkan pesan error. Ini dikarenakan plugin JWT harus dapan digunakan oleh semua Consumer. key claim name (optional): default yaitu iss. Disini saya mengubahnya menjadi key. header names (wajib): isi dengan value authorization.  Jika sudah klik Submit Changes. Bisa dilihat bahwa plugin JWT sudah ditambahkan.\nSelanjutnya, kita akan membuat Consumer. Masuk ke menu Consumers \u0026gt; Create Consumer. Buat username dan custom_id sesuai selera.\nSetelah consumer dibuat, masuk ke Consumer \u0026gt; Credentials \u0026gt; JWT. Lalu Create JWT.\nIsi key dan secret sesuai dengan selera kalian. Lalu submit.\nBisa dilihat bahwa Credential telah dibuat.\nTesting Berikutnya yaitu generate Bearer Token yang akan digunakan untuk autentikasi API. Sebagai contoh, kita akan menggunakan https://jwt.io. Masukkan key pada payload dan secret pada signature. Copy token yang ada pada sebelah kiri.\nSetelah Token digenerate, kita akan melakukan testing dengan menembak API. Disini saya menggunakan Insomnia. Tentu saja kalian bisa menggunakan tool sejenis seperti cURL, http, Postman, dll. Lalu copy token tersebut dan kita akan menempelkannya sebagai Bearer Token.\nSkenario I: Valid Token Skenario II: Invalid Token Skenario III: Tanpa Token Serial  Instalasi Kong Api Gateway \u0026amp; KONGA dengan Docker Compose Pembahasan Services dan Routes pada Kong Api Gateway Implementasi JWT Pada KONG \u0026lt;\u0026ndash; Kita disini  Referensi  https://konghq.com/blog/jwt-kong-gateway Pengalaman pribadi  Penutup Kurang lebih seperti itu cara menggunakan plugin JWT pada KONG. Jika ada pertanyaan silakan bertanya pada kolom komentar. Sekian dan Terimakasih\u0026hellip;\n","date":"2021-11-11T00:40:39+07:00","image":"https://blog.leonprasetya.my.id/p/implementasi-jwt-pada-kong/index_huac923ffed9f767788bc20bb1b6e92f9f_260380_120x120_fill_box_smart1_3.png","permalink":"https://blog.leonprasetya.my.id/p/implementasi-jwt-pada-kong/","title":"Implementasi JWT Pada KONG"},{"content":"Intro  Intro didalam Intro Sebelum saya buka\u0026hellip; Pertama-tama, saya mohon maaf jika ada pihak yang tersinggung, saya hanya ingin menceritakan pengalaman saya. Jika ada pihak yang merasa dirugikan, mohon hubungi saya untuk diskusi lebih lanjut. Terimakasih.\n Real Intro Halo teman-teman, pada artikel kali ini saya akan membahas pengalaman pribadi ketika saya mengikuti Bootcamp. Jadi kali ini saya juga memperingati bulan dimana saya pertama kali mengikuti test untuk masuk Bootcamp juga (jadi pas hehe), lalu pertanyaannya disini. Worth it kah ikut bootcamp?\nApa itu bootcamp? Bagi yang ngga ngerti. Bootcamp itu semacam pelatihan pada suatu bidang tertentu yang dikhususkan dan ditargetkan untuk memperdalam ilmu pada dunia kerja yang nyata. Misal, saya dulu ikut bootcamp dalam bidang DevOps Enginner. Ya kita dilatih tentang apa itu devops, caranya gimana, dll. Intinya gitu deh, saya ngga akan bahas detailnya hehehe.\nKenapa Bootcamp makin populer sekarang? Jadi diera pandemi ini, mungkin banyak yang kehilangan pekerjaannya atau untuk fresh graduate (seperti saya dulu) itu sangat sulit untuk mendapatkan pekerjaan. Dan melihat pekerjaan didunia digital diera pandemi ini sangat pesat perkembangannya, Otomatis\u0026hellip; Orang-orang pasti ingin mempelajari hal-hal tersebut, dan hadirlah bootcamp ini sebagai solusi cepat untuk mempelajari hal tersebut dalam waktu yang singkat (menurut pengalaman ane cuma sekitar 1 bulan). Misal nih, sebagai contoh yaitu teman seangkatan bootcamp saya, singkat cerita dipekerjaan dia yang sebelumnya karena kena imbas dari pandemi dan pendapatannya menurun dia memilih untuk beralih pekerjaan dan mengikuti bootcamp.\nLalu Worth It ga sih ikut Bootcamp? Well\u0026hellip; Menurut saya sendiri, saya sedikit kecewa. Eeeiittt\u0026hellip; Tunggu dulu\u0026hellip;!!! Alasan saya sedikit kecewa karena sebelum bootcamp berjalan saya sudah mempelajari tools-tools dan siklus devops itu sendiri, jadi yang saya dapet jujur saja cuma sedikit dan itu karena kesalahan saya sendiri karena tidak membaca silabusnya terlebih dahulu sebelum mengikuti bootcamp ini, namun ada satu alasan lain yang akan saya bahas pada bab berikutnya. Tapi\u0026hellip; Mungkin untuk teman-teman yang masih awam dan ingin banting setir ke bidang yang diinginkan, mengikuti Bootcamp itu saya rasa masih Worh It lah. Karena mereka juga memberikan gambaran dalam dunia kerja yang nyata dan juga mereka biasanya juga memberikan cerita tentang pengalaman-pengalaman mereka selama bekerja yang bisa jadi bahan acuan untuk diri kita.\nDisalurkan kerja? Menurut pengalaman saya sendiri dan teman-teman yang bernasib sama\u0026hellip; Saya akan menjawab, itu sih\u0026hellip; Hoki-hokian aja. Dan ini yang paling bikin saya dulu ngenes parah, karena sebenarnya alasan utama saya ikut bootcamp yaitu \u0026ldquo;Pengen cepet disalurkan kerja\u0026rdquo;. Dan kami ngga dapet itu cuuyy\u0026hellip; Mungkin ada manusia-manusia yang beruntung ya, sebelum bootcamp selesai udah dapet kerja. Tapi, itu hoki dan emang effort mereka sejak awal untuk mencari pekerjaan sendiri itu udah ada.\nPihak bootcamp (mungkin) juga sudah menyalurkan kita ke perusahaan rekan mereka, namun panggilan dari perusahaan tetap belum nampak pada email kami. Yang berujung pada NYARI SENDIRI sampai 50++ perusahaan sampai akhirnya saya diterima. Kalau ngga percaya, DM saya dicontact yang sudah saya list pada page About. Saya sih positive thinking aja ya, mungkin memang karena pandemi jadi perusahaan rekanan mereka lagi pada closed ya, atau emang CV dan Portofolio saya yang jelek makanya HRnya udah males baca dari awal.\nKesimpulan dan saran Beberapa kesimpulan dan saran yang dapat saya tulis, yaitu:\n Jika kalian sudah punya basicnya. Jangan malas-malas belajar sendiri. Mengingat biaya bootcamp itu tidaklah semurah yang kalian bayangkan. Usahakan cari informasi terlebih dahulu dari alumni-alumni bootcamp untuk menggambarkan bootcamp lebih jauh. Minta restu orang tua (wajib, kecuali kalian mbandel). Bandingkan bootcamp satu dengan yang lain. Karena bisnis bootcamp sekarang lagi menjamur, kalian ngga boleh main asal daftar aja. Bootcamp sebagai penambah gambaran dalam dunia kerja itu Oke. Seenggaknya pas kalian pertama masuk kerja kalian ngga goblok-goblok banget lah.  Penutup As the wise man said (which is me) \u0026ldquo;Pengalaman itu bukan didapatkan dari perkataan orang lain, melainkan dari apa yang telah kalian alami pada diri kalian sendiri\u0026rdquo;. Dan sekali lagi, saya mohon maaf jika ada pihak yang tersinggung, saya hanya ingin menceritakan pengalaman saya. Jika ada pihak yang merasa dirugikan, mohon hubungi saya untuk diskusi lebih lanjut. Dan untuk teman-teman, jika ada yang bisa diceritakan bisa ditulis pada kolom komentar dibawah.\nAkhir kata, Terimakasih.\n","date":"2021-09-12T13:42:22+07:00","image":"https://blog.leonprasetya.my.id/p/ikut-bootcamp.-worth-it-kah/index_hu4d774198880f7c0a6353b31646cec77f_965243_120x120_fill_box_smart1_3.png","permalink":"https://blog.leonprasetya.my.id/p/ikut-bootcamp.-worth-it-kah/","title":"Ikut Bootcamp. Worth It kah?"},{"content":"FYI  Saya akan membuat serial untuk pembelajaran KONG pada blog ini. Jadi ini adalah blog kedua tentang KONG yang akan dibahas disini dan selanjutnya masih ada lagi. Kita menggunakan KONG Community Edition Untuk mempermudah praktek, kita akan menggunakan KONGA  Serial  Instalasi Kong Api Gateway \u0026amp; KONGA dengan Docker Compose Pembahasan Services dan Routes pada Kong Api Gateway \u0026lt;\u0026ndash; Kita disini Implementasi JWT Pada KONG  Intro Melanjutkan yang minggu kemarin, kali ini kita akan membahas tentang Service \u0026amp; Route. Pertama pahami terlebih dahulu apa itu Service \u0026amp; Route.\n Service: adalah eksternal upstream API atau aplikasi yang kalian miliki. Contoh: http://dev.example.com Route: adalah gerbang keluar dari service yang nantinya akan diakses oleh user. Disini kita bisa membuat versioning service seperti contoh: http://dev.example.com/v1, http://dev.example.com/v2  Kalau kalian masih bingung tentang penjelasan saya, semoga kalian akan paham saat praktek. Jadi\u0026hellip; Mari kita mulai.\nPembahasan Contoh Project Disini saya memiliki contoh project yang bisa kita gunakan untuk praktek, buka link ini untuk mendownload atau clone repository. Ini akan digunakan sebagai contoh Service. Jika kalian menjalankannya lewat docker-compose. Kalian akan langsung bisa melakukan test APInya dengan perintah cURL pada:\n http://localhost:3000/one http://localhost:3000/two http://localhost:3000/three  Membuat Service dari contoh project Oke\u0026hellip; Saya asumsikan kalian udah paham tentang contoh projectnya. Sekarang kita akan membuat service. Buka KONGA kalian. Lalu buka menu Services \u0026gt; Add New Service. Munculah modal box seperti gambar dibawah.\nDisini form yang perlu kita tambahkan yaitu:\n Name: nama service, ini hanya nama, kalian bisa isi bebas. Contoh: service-v1. URL: URL diisi dengan link aplikasi yang kita miliki. Pastikan diisi dengan format \u0026lt;protocol\u0026gt;://\u0026lt;URL\u0026gt;:\u0026lt;port\u0026gt;. Contoh http://project:3000. Path: Ini sebenarnya form optional. Tapi\u0026hellip; Karena dalam contoh ini, kita menggunakan path untuk membedakan aplikasi. Kita akan memasukkan path dengan format /path. Contoh: /one.  Klik Submit Service.\nMembuat Routes Dari list Service yang telah kita buat. Klik pada nama salah satu service. Buka menu Routes \u0026gt; Add Route.\nHampir mirip seperti kita membuat Service sebelumnya, berikut form yang wajib kita tambahkan yaitu:\n Name: name ini wajib ya buat membedakan services/routes satu dengan yang lain. Path: path pada route bertujuan untuk membelokkan URL service ke path (/) yang kita tentukan. Misal http://feature.example.com --\u0026gt; http://example.com/feature. Intinya\u0026hellip; Mbelokin link doang. Contoh disini: /api/v1. Jangan lupa tekan ENTER. Method: dalam route ini http method apa saja yang diperbolehkan. Disini karena kita hanya nge-GET data doang. Ya isi aja GET. Jangan lupa tekan ENTER. Protocols: http or https. Terserah guys\u0026hellip; kalian juga udah paham pastinya kalo ini.  Klik Submit Route.\nLalu kita bisa cek URL yang telah kita proses melalui API Gateway tadi dengan cara melakukan HTTP Request ke http://localhost:8000/api/v1. Disini port 8000 adalah URL yang akan diakses oleh user. Dan /api/v1 adalah route yang telah kita buka tadi. Kita test menggunakan cURL.\n1 2 3 4 5 6 7 8 9 10 11 12 13  curl -IXGET localhost:8000/api/v1 ## Output HTTP/1.1 200 OK Content-Type: text/html; charset=utf-8 Content-Length: 6 Connection: keep-alive X-Powered-By: Express ETag: W/\u0026#34;6-no4iJdZG6USw2NYfw6FhZkLy+uw\u0026#34; Date: Sun, 22 Aug 2021 12:47:15 GMT X-Kong-Upstream-Latency: 2 X-Kong-Proxy-Latency: 1 Via: kong/2.3.3   Yep\u0026hellip; Kalian sudah berhasil membuat sepasang service \u0026amp; route.\nSerial  Instalasi Kong Api Gateway \u0026amp; KONGA dengan Docker Compose Pembahasan Services dan Routes pada Kong Api Gateway \u0026lt;\u0026ndash; Kita disini Implementasi JWT Pada KONG  Penutup Oke untuk sekarang sekian dulu, sorry kalau agak kurang jelas. Semoga artikel ini membantu, jika ada pertanyaan silakan isi pada kolom komentar. Terimakasih.\n","date":"2021-08-22T14:53:48+07:00","image":"https://blog.leonprasetya.my.id/p/pembahasan-services-dan-routes-pada-kong-api-gateway/index_huac923ffed9f767788bc20bb1b6e92f9f_260380_120x120_fill_box_smart1_3.png","permalink":"https://blog.leonprasetya.my.id/p/pembahasan-services-dan-routes-pada-kong-api-gateway/","title":"Pembahasan Services dan Routes pada Kong Api Gateway"},{"content":"Intro By default installasi RedHat 8 Linux bakal dijalankan pada graphical mode. Disini kita akan menggunakan Text Mode TTY installation. Ini sebenarnya didesain untuk \u0026ldquo;JIKA\u0026rdquo; kalian memiliki masalah dengan graphical mode, kalian bisa menggunakan text mode untuk pilihan ke-2.\nRequirements  File instalasi ISO RHEL 8 Software virtualisasi (jika belajar)  Saat kalian baru booting pasti terlihat seperti ini.\nPada screenshot diatas, kita bisa menekan tombol TAB untuk konfigurasi yang kostum. Maka kita akan tekan TAB dan masukkan text berikut diakhir baris konfigurasi GRUB.\n1  ... inst.text   Seperti ini\nLalu tekan ENTER, maka kalian sudah bisa menggunakan installasi text mode.\nSekian tutorial singkat dari saya. Terimakasih\n","date":"2021-07-25T20:28:27+07:00","permalink":"https://blog.leonprasetya.my.id/p/rhel-8-install-text-mode/","title":"RHEL 8 Install Text Mode"},{"content":"FYI  Saya akan membuat serial untuk pembelajaran KONG pada blog ini. Jadi ini adalah blog pertama tentang KONG yang akan dibahas disini dan selanjutnya masih ada lagi. Kenapa menggunakan kontainer? Karena KONG bersifat stateless yang bisa discale berapapun dan bisa dirubah kapanpun. Namun untuk database, karena kita hanya belajar maka jangan dipikirkan dulu. Kita menggunakan KONG Community Edition  Serial  Instalasi Kong Api Gateway \u0026amp; KONGA dengan Docker Compose \u0026lt;\u0026ndash; Kita disini Pembahasan Services dan Routes pada Kong Api Gateway Implementasi JWT Pada KONG  Intro KONG API Gateway adalah Load Balancer dengan fitur-fitur yang kaya. Beda dengan load balancer lain, dengan KONG menggunakan fitur seperti Rate Limiting, Caching, Logging, Autentikasi dll menjadi lebih mudah karena KONG memaketkan fitur-fiturnya dengan format Plugin. Sorry saya bukannya mau ngepromote KONG, cuma yang saya rasakan seperti itu wkwk.\nTL;DR Kalian udah paham? Tapi kesini cuma mau cari docker-compose-nya aja? Langsung aja clone repo ini https://github.com/ledleledle/belajar-kong.\nDB-Mode vs DB-Less Kong memiliki 2 pilihan diantaranya, DB-Mode yaitu KONG dengan database, database yang dapat disupport ada 2 yaitu PostreSQL dan Cassandra. Dan DB-Less yaitu KONG tanpa database, yaitu kita bisa menggunakan file .yml untuk melakukan konfigurasi terhadap KONG. Namun kali ini saya akan menggunakan DB-Mode dengan database PostgreSQL.\nGood Point Seperti yang saya jelaskan pada intro, karena KONG memiliki pluginnya sendiri, kita dapat memanfaatkan fitur-fiturnya tanpa perlu membuat service dengan fitur yang sama satu per satu. Lebih gampangnya mari kita lihat gambar dibawah.\nYa karena eranya microservices, mungkin kita akan memecah beberapa services, hanya saja ada fitur-fitur yang diperlukan ditiap servicenya misal pada gambar diatas yaitu Logging dan Security. Dengan KONG kita bisa membuatnya lebih simpel dengan mengimplementasi plugin pada level API Gateway seperti pada gambar dibawah.\nInstalasi Mungkin kita akan membahas instalasinya terlebih dahulu, berikut adalah hal-hal yang akan dipakai dalam praktek ini.\n Docker \u0026amp; Docker Compose KONG Community Edition KONGA (Admin WEB UI, untuk mempermudah penggunaan KONG)  Siapkan sebuah folder dan file docker-compose.yml.\n1 2  mkdir kong-api-gateway \u0026amp;\u0026amp; cd kong-api-gateway touch docker-compose.yml   Lalu edit file docker-compose.yml yang telah kita buat dengan konfigurasi dibawah. Mari kita bahas step-by-step untuk komponen-komponennya.\n1  version:\u0026#34;3.0\u0026#34;  Format dokumen docker compose yang dipakai yaitu 3.0. Untuk lebih detailnya, bisa kalian lihat pada dokumentasi docker compose berikut.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  services:kong-database:image:postgres:9.6restart:alwaysvolumes:- ./postgres-data:/var/lib/postgresql/dataenvironment:- POSTGRES_USER=user- POSTGRES_PASSWORD=12345- POSTGRES_DB=kong_dbports:- 5432:5432networks:- kong-net  Sediakan databasenya, disini saya menggunakan versi postgres:9.6 (tidak ada alasan khusus, kalian bisa menggunakan versi yang berbeda). Untuk membuat databasenya lebih persistent, saya juga membuat volume yang mengarah pada directory postgres-data. Set USER, PASSWORD dan DB pada environment. Dan join network ke kong-net untuk menghubungkan container satu dengan yang lain pada jaringan yang sama.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  kong-migrate:image:kong:2.3.3restart:on-failurecommand:kong migrations bootstrapenvironment:- KONG_DATABASE=postgres- KONG_PG_HOST=kong-database- KONG_PG_DATABASE=kong_db- KONG_PG_USER=user- KONG_PG_PASSWORD=12345depends_on:- kong-databasenetworks:- kong-net  Lalu ada perintah migrate, yaitu KONG akan melakukan migrasi database dan seluruh table agar KONG dapat berjalan dengan normal. Masukkan DATABASE, USER dan PASSWORD postgres yang telah didefinisikan sebelumnya pada environment kong-migrate. depends_on yaitu perintah untuk menunggu suatu container yang dispesifikasikan untuk berjalan terlebih dahulu, barulah container selanjutnya akan dijalankan.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  kong:image:kong:2.3.3restart:alwaysenvironment:- KONG_LOG_LEVEL=debug- KONG_DATABASE=postgres- KONG_PG_HOST=kong-database- KONG_PG_DATABASE=kong_db- KONG_PG_USER=user- KONG_PG_PASSWORD=12345- KONG_PROXY_ACCESS_LOG=/dev/stdout- KONG_ADMIN_ACCESS_LOG=/dev/stdout- KONG_PROXY_ERROR_LOG=/dev/stderr- KONG_ADMIN_ERROR_LOG=/dev/stderr- KONG_ADMIN_LISTEN=0.0.0.0:8001- KONG_PROXY_LISTEN=0.0.0.0:8000- KONG_PROXY_LISTEN_SSL=0.0.0.0:8443ports:- 8000:8000- 8443:8443- 8001:8001- 8444:8444depends_on:- kong-migrate- kong-databasenetworks:- kong-net  Setelah migrasi selesai, selanjutnya kita bisa menjalankan KONG. Seperti sebelumnya, masukkan DATABASE, USER dan PASSWORD postgres yang telah didefinisikan sebelumnya pada environment kong. Sebenarnya dari sini kita sudah bisa menggunakan KONG melalui HTTP Request seperti cURL atau Postman. Namun untuk mempermudah penggunaan KONG, kita akan memasang WEB UI yang dibuat oleh komunitas yaitu KONGA.\n1 2 3 4 5 6 7 8 9 10  konga-prepare:image:pantsel/konga:0.14.9command:\u0026#34;-c prepare -a postgres -u postgresql://user:12345@kong-database:5432/konga_db\u0026#34;networks:- kong-netrestart:on-failurelinks:- kong-databasedepends_on:- kong-database  Untuk KONGA kita juga membutuhkan database, jadi kita juga akan melakukan migrasi database untuk KONGA, kita bisa menggunakan database yang sama yang kita gunakan untuk KONG. Untuk mengisikan USERNAME, PASSWORD dan DATABASE PostgreSQL, pada KONGA kita menggunakan format URL seperti postgresql://user_anda:password_anda@host_atau_ip_anda:5432/db_anda.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  konga:image:pantsel/konga:0.14.9restart:on-failurenetworks:- kong-netenvironment:- DB_ADAPTER=postgres- DB_HOST=kong-database- DB_USER=user- DB_PASSWORD=12345- TOKEN_SECRET=km1GUr4RkcQD7DewhJPNXrCuZwcKmqjb- DB_DATABASE=konga_db- NODE_ENV=productiondepends_on:- kong-databaseports:- \u0026#34;1337:1337\u0026#34;  Setelah migrasi KONGA database selesai, barulah kita bisa melakukan deployment KONGA. Konfigurasinya overall hampir sama, jadi tidak usah saya jelaskan. Untuk TOKEN_SECRET sebenarnya bisa diisi bebas, tapi disini saya mengikuti dokumentasinya saja.\n1 2 3  networks:kong-net:driver:bridge  Ini adalah network yang dipanggil disetiap service, Network bersifat bridge.\nJadi, konfigurasi penuhnya akan terlihat seperti berikut.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99  version:\u0026#34;3.0\u0026#34;services:kong-database:image:postgres:9.6restart:alwaysvolumes:- ./postgres-data:/var/lib/postgresql/dataenvironment:- POSTGRES_USER=user- POSTGRES_PASSWORD=12345- POSTGRES_DB=kong_dbports:- 5432:5432networks:- kong-netkong-migrate:image:kong:2.3.3restart:on-failurecommand:kong migrations bootstrapenvironment:- KONG_DATABASE=postgres- KONG_PG_HOST=kong-database- KONG_PG_DATABASE=kong_db- KONG_PG_USER=user- KONG_PG_PASSWORD=12345depends_on:- kong-databasenetworks:- kong-netkong:image:kong:2.3.3restart:alwaysenvironment:- KONG_LOG_LEVEL=debug- KONG_DATABASE=postgres- KONG_PG_HOST=kong-database- KONG_PG_DATABASE=kong_db- KONG_PG_USER=user- KONG_PG_PASSWORD=12345- KONG_PROXY_ACCESS_LOG=/dev/stdout- KONG_ADMIN_ACCESS_LOG=/dev/stdout- KONG_PROXY_ERROR_LOG=/dev/stderr- KONG_ADMIN_ERROR_LOG=/dev/stderr- KONG_ADMIN_LISTEN=0.0.0.0:8001- KONG_PROXY_LISTEN=0.0.0.0:8000- KONG_PROXY_LISTEN_SSL=0.0.0.0:8443ports:- 8000:8000- 8443:8443- 8001:8001- 8444:8444depends_on:- kong-migrate- kong-databasenetworks:- kong-netkonga-prepare:image:pantsel/konga:0.14.9command:\u0026#34;-c prepare -a postgres -u postgresql://user:12345@kong-database:5432/konga_db\u0026#34;networks:- kong-netrestart:on-failurelinks:- kong-databasedepends_on:- kong-databasekonga:image:pantsel/konga:0.14.9restart:on-failurenetworks:- kong-netenvironment:- DB_ADAPTER=postgres- DB_HOST=kong-database- DB_USER=user- DB_PASSWORD=12345- TOKEN_SECRET=km1GUr4RkcQD7DewhJPNXrCuZwcKmqjb- DB_DATABASE=konga_db- NODE_ENV=productiondepends_on:- kong-databaseports:- \u0026#34;1337:1337\u0026#34;project:build:./projectrestart:alwaysnetworks:- kong-netports:- \u0026#34;3000:3000\u0026#34;networks:kong-net:driver:bridge  Simpan dan jalankan perintah, lalu tunggu beberapa menit untuk menunggu database, table dan container disiapkan.\n1  docker-compose up -d   Setelah semuanya selesai, kita bisa akses localhost:1337. Untuk pertama kali kalian akan dimintai untuk mendaftar, ini adalah salah satu fitur KONGA yaitu kita bisa memberikan Role Based Access Control (RBAC). Dan setelah login, kita akan mendapatkan tampilan seperti berikut.\nMenambah Connection Connection disini yaitu Admin API KONG, Disini kita bisa menyambungkan beberapa KONG Nodes yang ingin kita konfigurasi. Cara menambahkannya simple. Cukup masukkan URL KONG yang sudah kalian deploy, lalu simpan.\nSerial  Instalasi Kong Api Gateway \u0026amp; KONGA dengan Docker Compose \u0026lt;\u0026ndash; Kita disini Pembahasan Services dan Routes pada Kong Api Gateway Implementasi JWT Pada KONG  References  https://hub.docker.com/r/pantsel/konga/ https://hub.docker.com/_/kong https://docs.konghq.com/gateway-oss/2.4.x/db-less-and-declarative-config/  Penutup Okay\u0026hellip; Sudah dulu, untuk fitur-fitur yang lain dan cara penggunaan KONGA. Kita akan bahas pada artikel berikutnya (sorry ngantuk). Oke sekian dulu, semoga artikel ini membantu, jika ada pertanyaan silakan isi pada kolom komentar. Terimakasih.\n","date":"2021-07-17T14:53:48+07:00","image":"https://blog.leonprasetya.my.id/p/instalasi-kong-api-gateway-konga-dengan-docker-compose/index_huac923ffed9f767788bc20bb1b6e92f9f_260380_120x120_fill_box_smart1_3.png","permalink":"https://blog.leonprasetya.my.id/p/instalasi-kong-api-gateway-konga-dengan-docker-compose/","title":"Instalasi Kong Api Gateway \u0026 KONGA dengan Docker Compose"},{"content":"Maafkan saya yang akhir-akhir ini tidak menulis blog (2 bulan), dikarenakan kerjaan yang padat dan manajemen waktu yang buruk. Namun sekarang saya senggang dan mampu untuk menulis blog.\nIntro Kadang untuk alasan privasi atau mencari kecepatan dalam deployment, seseorang atau suatu perusahaan akan memilih untuk membuat Container Registry-nya sendiri, apalagi sekarang lagi populer banget development aplikasi menggunakan kontainer, cocok banget. Untuk itu dibuatlah artikel ini. Namun pada artikel ini saya hanya akan memberikan contoh kecilnya saja, yang mungkin bisa kalian kembangkan misal kalian ingin membuat cluster container registry, dsb. Okay langsung saja.\nRequirement  Docker Docker Compose Nginx Certbot/LetsEncrypt (HTTPS bro/gak wajib) Sebuah domain (jika anda orang yang mampu/gak wajib)  Susunan file \u0026amp; directory 1 2 3 4 5  container-registry ├── auth │ ├── htpasswd ├── docker-compose.yaml └── registry   Berikut adalah susunan file \u0026amp; directory yang akan digunakan, asumsikan folder utama kita (workdir) bernama container-registry, didalamnya ada directory bernama auth dan registry, auth berisi file htpasswd yang berguna untuk menyimpan user \u0026amp; password sedangkan directory registry adalah folder yang akan digunakan untuk menyimpan semua image yang dipush oleh user. Dan jangan lupakan file docker-compose.yaml, file yang berisi konfigurasi kontainer.\nStep-by-step Ya\u0026hellip; HTTPS dan domain itu tidak wajib karena tidak semua orang memiliki uang yang cukup untuk membeli sebuah domain (seperti saya). Sebenarnya untuk login docker registry membutuhkan request HTTPS, tapi kita bisa mem-bypassnya, nanti bakal saya jelasin diakhir artikel.\nDocker-compose file Pertama, kita akan mendeploy sebuah container registry, dan untungnya Docker sudah membuat imagenya agar kita bisa lebih mudah dalam membuat container registry secara pribadi. Pada artikel ini dibuat, docker registry masih dalam versi 2.7.0. Jika ingin menggunakan versi terbaru kalian bisa cek pada Docker Hub.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  version: \u0026#34;3.0\u0026#34;services: registry: image: registry:2.7.0 restart: always ports:  - 5000:5000 environment: REGISTRY_AUTH: htpasswd REGISTRY_AUTH_HTPASSWD_PATH: /auth/htpasswd REGISTRY_AUTH_HTPASSWD_REALM: Registry Realm volumes:  - ./registry:/var/lib/registry - ./auth:/auth  Tapi jangan dideploy terlebih dahulu! Karena kita harus membuat autentikasi password terlebih dahulu.\nAutentikasi Tentu saja kita ingin, registry kita hanya dimasuki oleh orang yang kita beri akses, untuk itu kita harus membuat autentikasi agar user harus login untuk dapat menggunakan registry ini. Masukkan perintah berikut.\n1 2 3 4  ## Buat folder bernama \u0026#34;auth\u0026#34; mkdir auth ## Membuat file \u0026#34;htpasswd\u0026#34; didalam folder \u0026#34;auth\u0026#34;, dengan user \u0026#34;blog\u0026#34; \u0026amp; password \u0026#34;blogleon666\u0026#34; docker run --rm --entrypoint htpasswd registry:2.7.0 -Bbn blog blogleon666 \u0026gt; auth/htpasswd   Deployment Step paling gampang yaitu deployment, karena kita hanya akan menjalankan satu perintah saja.\n1  docker-compose up -d   Konfigurasi domain dan SSL Pada artikel ini, kita akan menggunakan SSL gratis yaitu Certbot/LetsEncrypt. Pertama install terlebih dahulu Certbot \u0026amp; Nginx.\n1 2 3 4 5 6 7 8 9  ## Install Certbot sudo snap install core; sudo snap refresh core sudo snap install --classic certbot sudo ln -s /snap/bin/certbot /usr/bin/certbot ## Install Nginx Debian Base sudo apt install nginx -y ## Install Nginx Arch Base sudo pacman -Sy nginx   Reverse Proxy Buat reverse proxy terlebih dahulu untuk mengalihkan IP Address server dengan domain yang kita miliki. Kita tidak perlu membuat konfigurasi untuk HTTPS karena nantinya akan digenerate otomatis oleh Certbot.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // Gunakan text editor favorit kalian cd /etc/nginx/sites-available sudo nano registry.conf // Isi dari registry.conf server { client_max_body_size 666M; server_name registry.leonprasetya.my.id; location / { proxy_pass http://172.168.10.1:5000;  } } // Aktifkan reverse proxy sudo ln -s /etc/nginx/sites-available/registry.conf /etc/nginx/sites-enable    client_max_body_size adalah limit upload yang diperbolehkan, kalian bisa atur sesuka hati, namun saya lebih suka memberi angka yang demonic!!! server_name adalah nama domain kalian. proxy_pass adalah alamat IP Address server yang dideploy container registry.  SSL/HTTPS Let the magic happen. Dengan Certbot, memasang SSL akan terasa sangat mudah.\n1  sudo certbot --email email_anda@gmail.co.id --nginx -d registry.leonprasetya.my.id   Ketika proses selesai, coba buka file /etc/nginx/sites-available/registry.conf untuk memastikan bahwa konfigurasi SSL sudah berhasil. Jika sudah selesai kurang lebih outputnya akan terlihat seperti ini.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  server { server_name registry.leonprasetya.my.id; location / { proxy_pass http://172.168.10.1:5000;  proxy_http_version 1.1; proxy_cache_bypass $http_upgrade; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;upgrade\u0026#34;; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Port $server_port; } listen 443 ssl; # managed by Certbot ssl_certificate /etc/letsencrypt/live/registry.leonprasetya.my.id/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/registry.leonprasetya.my.id/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot } server { if ($host = registry.leonprasetya.my.id) { return 301 https://$host$request_uri;  } # managed by Certbot listen 80; server_name registry.leonprasetya.my.id; return 404; # managed by Certbot }   Testing Pemasangan Reverse Proxy dan SSL adalah step terakhir yang kita lalui, sekarang saatnya untuk mencoba container registry yang telah kita deploy.\nLogin 1 2 3 4 5 6 7 8 9  # Login dengan username \u0026amp; password yang kita buat sebelumnya! docker login registry.leonprasetya.my.id Username: blog Password: \u0026lt;password_kita\u0026gt; WARNING! Your password will be stored unencrypted in /home/leon/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded   Pull \u0026amp; Push Image 1 2 3 4  docker pull ubuntu:16.04 docker tag ubuntu:16.04 registry.leonprasetya.my.id/my-ubuntu docker push registry.leonprasetya.my.id/my-ubuntu docker pull registry.leonprasetya.my.id/my-ubuntu   Jika tidak paham dengan command berikut, kalian bisa cek pada aritek saya yang sebelumnya yaitu Docker Untuk Pemula hehehe\u0026hellip;\nCek Images Pada container registry ini, kita tidak dapat menggunakan perintah docker search seperti biasanya, sebagai gantinya kita bisa melakukan pengecekan atau melihat semua daftar images pada container registry ini menggunakan HTTP request. Seperti contoh.\n1 2 3  curl -X GET http://blog:blogleon666@registry.leonprasetya.my.id/v2/_catalog # Output  {\u0026#34;repositories\u0026#34;:[\u0026#34;my-ubuntu\u0026#34;,\u0026#34;postgres\u0026#34;]}   Kita juga dapat melihat list tags pada sebuah image.\n1 2 3  curl -X GET http://blog:blogleon666@registry.leonprasetya.my.id/v2/postgres/tags/list # Output {\u0026#34;name\u0026#34;:\u0026#34;postgres\u0026#34;,\u0026#34;tags\u0026#34;:[\u0026#34;9.6\u0026#34;]}   Insecure Container Registry Seperti yang saya janjikan diawal artikel ini, untuk teman-teman yang tak memiliki domain atau yang benar-benar hanya ingin Container registry ini diakses secara local, namun normalnya jika kalian mengaksesnya menggunakan menggunakan direct IP Address ataupun protokol HTTP, Docker akan melempar error http: server gave http response to https client. Dan inilah yang akan kita bahas pada bab ini. Buat file daemon.json untuk membuat list insecure-registries (insecure seperti saya).\n1 2 3 4 5  sudo nano /etc/docker/daemon.json { \u0026#34;insecure-registries\u0026#34; : [\u0026#34;172.168.10.1:5000\u0026#34;] }   Lalu restart Docker kalian terlebih dahulu. Contoh dibawah menggunakan systemd.\n1  sudo systemctl restart docker.service   Lalu kalian bisa login.\n1  docker login 172.168.10.1:5000   Konsiderasi Sebenarnya ada produk Container Registry lain yang ada seperti JFrog dan Nexus keduanya memiliki Web Interface yang memudahkan kita untuk me-manage registry, namun saya memilih Docker karena deployment yang simple dan minimalist. Selalu ada Pro dan Kontra dalam memilih sesuatu, namun kita hanya harus memilih yang cocok untuk kita pakai.\nPenutup Oke sekian artikel pada hari ini, saya sangat senang akhirnya bisa menulis lagi, seperti biasa jika ada pertanyaan/typo/kurang jelas, kalian bisa berdiskusi pada kolom komentar. Sekian dan terimakasih.\nReferensi  https://stackoverflow.com/questions/31251356/how-to-get-a-list-of-images-on-docker-registry-v2 https://docs.docker.com/registry/recipes/nginx https://docs.docker.com/registry/deploying https://medium.com/@dataq/membuat-docker-private-registry-6efe534df4d5  ","date":"2021-05-21T14:53:48+07:00","image":"https://blog.leonprasetya.my.id/p/membuat-private-registry/private_hu96599f47c348a283a1b794be0a0813f9_135854_120x120_fill_box_smart1_3.png","permalink":"https://blog.leonprasetya.my.id/p/membuat-private-registry/","title":"Membuat Private Registry"},{"content":"Dummy Output biasanya terjadi setelah update, umumnya ini terjadi pada OS yang memiliki karakteristik Rolling Release seperti Arch Linux. Sebenarnya kejadian ini sangat jarang terjadi, bahkan saya baru sekali ini mengalami kondisi seperti ini.\nSolusi 1  pulseaudio --check; pulseaudio --kill; pulseaudio --start   Referensi  https://askubuntu.com/questions/15223/how-can-i-restart-pulseaudio-without-having-to-logout/15224#15224 https://bandithijo.github.io/blog/restart-pulseaudio-dummy-output-tanpa-logout  ","date":"2021-03-11T02:11:23+07:00","permalink":"https://blog.leonprasetya.my.id/p/pulse-audio-dummy-output/","title":"Pulse Audio Dummy Output"},{"content":"Sebenarnya saya telat ya menulis artikel ini, karena saya malah sudah membahas container orchestration wkwkwk. Jadi saya menulis ini dikarenakan ada seseorang yang meminta saya untuk dijelaskan tentang Docker, dia seorang programmer yang baru saja mendapat pekerjaan dan perusahaannya (mungkin) menuntut dia agar bisa menguasai Docker. Sekarang yang jadi pertanyaan, \u0026ldquo;Kenapa seorang programmer harus memahami Docker?\u0026rdquo;, jawabannya adalah (menurut saya) dikarenakan konsep Microservices yang kian populer kontainerisasi menjadi sesuatu yang penting didalam suatu instansi/perusahaan, sebenarnya ada seorang DevOps yang akan mengurus tentang kontainerisasi, namun programmer pun akan dipaksa bekerja dalam environment kontainer tersebut yang menghasilkan statement bahwa programmer pun juga harus mengenal atau menguasai kontainerisasi dalam konteks artikel ini yaitu Docker. Atau dalam kasus lain, dikantornya mungkin dia adalah Programmer Superman.\nApa itu Docker dan Apa perbedaannya dengan VM Seperti yang sudah saya singgung sebelumnya tentang kontainerisasi, Docker merupakan sebuah tempat yang menampung program beserta library, file konfigurasi, dll. Kontainer ini berbeda dengan virtual machine yang mana perbedaanya terdapat pada penggunnan sistem operasi pada masing-masing nodenya. Virtualisasi berjalan diatas hypervisor dan guest OS, docker dapat menjalankan aplikasi langsung tanpa kedua hal tersebut. Lebih jelasnya perhatikan bagan berikut :\nKenapa Pakai Docker?  Ya\u0026hellip; seperti yang sudah anda baca diatas, daripada kita menggunakan VM untuk aplikasi berbasis microservices, yang harus melakukan installasi OS, Aplikasi, library, dll. Lebih baik menggunakan container. VM juga saya rasa terlalu boros dalam hal resources terutama storage. Jadi kehadiran docker sangat membantu kita. Untuk Docker sendiri menurut saya penggunaannya simpel dan perintah-perintahnya mudah dipahami (namun docsnya lumayan sampah). Docker bersifat Open source dibawah lisensi Apache Versi 2.0 yang bisa dipergunakan secara gratis.  Komponen Docker Terdapat beberapa komponen pada Docker yang saling membutuhkan satu sama lain. Diantaranya adalah :\n Docker Image : merupakan sebuah template yang bersifat read-only, di dalamnya akan terdapat sistem operasi beserta aplikasi. Image dasar dapat dibuat sendiri dengan menambahkan aplikasi yang dibutuhkan ke dalam Dockerfile dan hasilnya dapat kita simpan ke Registry. Docker Container : merupakan runtime instance dari Docker image. Container mengandung seluruh kebutuhan untuk aplikasi sehingga aplikasi dapat berjalan dengan cara yang terisolasi. Docker Registry : merupakan komponen penyimpanan untuk Docker image. Berupa repository yang dapat diatur public maupun private, untuk kepentingan kolaborasi bersama orang lain. Docker Hub merupakan repository cloud yang disediakan oleh Docker secara gratis. Docker Hub sendiri adalah repository yang bersifat public. Jika ingin private, mungkin kalian dapat mencoba Gitlab, Bitbucket, dll. Dockerfile : berupa file yang mengandung serangkaian instruksi tentang bagaimana membangun Docker Image. Docker image tersebut mengandung setiap kode dengan dependensinya. Contoh Dockerfile yang sederhana dengan image node.js versi 10.  1 2 3 4 5  FROMnode:10WORKDIR/usr/appCOPY . .EXPOSE3000CMD [\u0026#34;node\u0026#34;, \u0026#34;index.js\u0026#34;]  Pelajari Dulu Basic Commandnya Basic Command ini sebenarnya, perintah-perintah Docker yang sering digunakan saja, untuk perintah-perintah yang lain silahkan kalian explore sendiri ya. Saya sengaja menuliskannya berurutan, agar kalian mudah untuk mempelajarinya terutama step-by-stepnya. Langsung saja, berikut adalah listnya :\nMengunduh Docker Image Kita bisa mengunduh Docker image dari registry dengan perintah Docker Pull. Commandnya sangat sederhana, sebagai contoh saya ingin mengunduh image nginx dengan tag latest.\n1  docker pull nginx:latest   Melihat daftar image yang dimiliki 1 2 3  docker images # Atau docker image ls   Mengganti nama/tag image Ini biasanya berfungsi saat kita ingin mengunggah image ke registry docker hub. Dalam docker hub, image yang diunggah harus berformat \u0026lt;username\u0026gt;/\u0026lt;nama_image\u0026gt;. Berikut contoh perintahnya.\n1 2 3  docker tag \u0026lt;nama_image\u0026gt;:\u0026lt;tag\u0026gt; \u0026lt;username\u0026gt;/\u0026lt;nama_image\u0026gt;:\u0026lt;tag\u0026gt; # Contoh docker tag nginx:latest leon0408/nginx:10.0   Menghapus Image 1 2 3 4  # Delete 1 image docker image rm nginx:latest # Delete semua image yang tidak terpakai docker image prune -a   Membuat Docker Image Untuk langkah ini, sebenarnya kita harus punya Dockerfile terlebih dahulu. Anyway\u0026hellip; Berikut perintahnya.\n1 2 3  docker build -t \u0026lt;nama_image\u0026gt; \u0026lt;direktori_dockerfile\u0026gt; # Contoh docker build -t aplikasi_kasir .   Membuat Container 1 2 3  docker container create --name \u0026lt;nama_container\u0026gt; -p \u0026lt;port_yang_dikeluarkan\u0026gt;:\u0026lt;port_container\u0026gt; \u0026lt;nama_image\u0026gt; # Contoh docker container create --name server-nginx -p 80:80 nginx   Menjalankan Container 1 2 3  docker start \u0026lt;nama_container\u0026gt; # Contoh docker start server-nginx   Membuat sekaligus Menjalankan Container Sebenarnya ada cara untuk membuat container sekaligus menjalankannya, yaitu dengan menggunakan perintah docker run. Jika kalian lihat perintah dibawah terdapat -d, itu berfungsi agar container berjalan di backgroud. Karena defaultnya, dengan perintah ini container akan berjalan dengan menampilkan log.\n1 2 3  docker run -d -p \u0026lt;port_yang_dikeluarkan\u0026gt;:\u0026lt;port_container\u0026gt; --name \u0026lt;nama_container\u0026gt; \u0026lt;nama_image\u0026gt; # Contoh docker run -d -p 81:80 --name server-nginx-2 nginx   Lalu bisa kalian cek dengan membuka browser, lalu memasukkan URL http://localhost:81.\nMelihat Container 1 2 3 4 5 6 7  # Melihat Container yang berjalan docker ps # Melihat semua Container docker ps -a # Output dd8749428a66 nginx \u0026#34;/docker-entrypoint.…\u0026#34; 3 seconds ago Up 2 seconds 0.0.0.0:81-\u0026gt;80/tcp server-nginx-2 54a5c626a82b nginx \u0026#34;/docker-entrypoint.…\u0026#34; 4 minutes ago Up 2 minutes 0.0.0.0:80-\u0026gt;80/tcp server-nginx   Stop \u0026amp; Restart Container 1 2 3 4  # Stop docker stop \u0026lt;nama_container\u0026gt; # Restart docker restart \u0026lt;nama_container\u0026gt;   Menghapus Container Untuk menghapus kontainer, posisi kontainer harus dalam keadaan mati/stopped. Jika ingin menghapus kontainer yang sedang berjalan secara paksa, kalian bisa menambahkan flag -f.\n1 2 3  docker container rm \u0026lt;nama_container\u0026gt; # Atau docker rm \u0026lt;nama_container\u0026gt;   Login Registry Sebagai contoh, disini saya login ke registry docker hub, dengan akun saya sendiri.\n1 2 3 4 5 6 7 8 9 10 11  # Command docker login # Login Prompt Login with your Docker ID to push and pull images from Docker Hub. If you don\u0026#39;t have a Docker ID, head over to https://hub.docker.com to create one. Username: leon0408 Password: WARNING! Your password will be stored unencrypted in /home/dark/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded   Push Image ke Registry Jika kalian bingung kenapa imagenya tidak bisa diunggah karena tadi bacanya di skip-skip. Mending kalian baca lagi perintah untuk mengganti nama image.\n1 2 3  docker push \u0026lt;nama_image\u0026gt;:\u0026lt;tag\u0026gt; # Contoh docker push leon0408/nginx:10.0   Penutup Menurut saya sampai disitu saja penjelasan dari saya. Jika ada tambahan atau pertanyaan, silahkan tampung pada kolom komentar. Sekian dan terimakasih\u0026hellip;\nReferensi  https://docs.docker.com Pengalaman Pribadi  ","date":"2021-02-03T20:51:05+07:00","image":"https://blog.leonprasetya.my.id/p/docker-untuk-pemula/index_hu3561eeb3844479899fe4e56a13632573_318896_120x120_fill_box_smart1_3.png","permalink":"https://blog.leonprasetya.my.id/p/docker-untuk-pemula/","title":"Docker Untuk Pemula"},{"content":"Setelah sebelumnya saya telah membahas tentang Provisioning Server hingga membuat Kubernetes Cluster. Kali ini saya ingin membahas tentang Kubernetes Dashboard yang menawarkan kemudahan dalam membuat Cluster yaitu Rancher. Pokoknya requirement pada artikel kali ini hanyalah Docker dan kopi (prosesnya lumayan lama). Penasaran? Langsung saja kita bahas\u0026hellip;\nSeperti biasa, untuk tujuan praktek siapkan 3 instance, jika tidak tahu caranya kalian bisa liat pada artikel saya sebelumnya tentang Provisioning Server. 1 untuk control plane \u0026amp; etcd dan 2 untuk worker. Jadi konsepnya kita install 1 control plane, pada control plane kita bisa membuat Custom Cluster, disana kita akan diberikan command untuk mengkonfirmasi instance yang akan masuk kedalam Cluster (hampir mirip dengan kubeadm).\nOkay\u0026hellip; mari kita install Docker. Disini saya menggunakan Ubuntu Server 18.04. Untuk installasi Docker dapat kalian baca disini. Pastikan kalian install disemua server, karena semuanya akan dijalankan melalui Docker.\nSetelah Docker terinstall, langkah selanjutnya yaitu membuat container untuk Control Plane Rancher. Masukkan perintah dibawah. Saya pakai versi 2.4.6 yang stabil.\n1 2 3  docker run -d --restart=unless-stopped \\  -p 80:80 -p 443:443 \\  rancher/rancher:v2.4.6   Masuk melalui browser dengan alamat https://. By default Rancher akan berjalan pada port 80 dan 443. Jadi siapkan SSL atau kalian akan mendapatkan error seperti gambar dibawah.\nSebenarnya mendapat error seperti ini pun Rancher masih dapat digunakan. Jadi jangan panik dulu. Masukkan password baru untuk Rancher kalian, setelah itu kita akan diarahkan pada Dashboard Rancher.\nUntuk membuat Cluster baru, klik pada Add Cluster \u0026gt; Existing Nodes. Sebenarnya ada banyak pilihan, namun karena kita sudah membuat instance sebelumnya jadi kita akan menggunakan Menu Existing Nodes.\nHal-hal yang saya gunakan saat membuat Cluster Baru :\n Cluster Name : Terserah kalian Kubernetes Version : Sesuai kebutuhan (saya menggunakan yang terbaru) Network Provider : Sesuai kebutuhan juga (saya menggunakan Weave) Cloud Provider : None  Setelah semua yang diatas telah diisi, langkah selanjutnya yaitu melakukan inisialisasi role pada instance kita. Disini kita akan mendapatkan pilihan role untuk Cluster kita, dan nantinya kita akan diberikan perintah (Docker command) yang harus dijalankan pada setiap instance kita.\nPertama kita membuat etcd \u0026amp; control-plane node terlebih dahulu.\nLalu buat juga untuk worker node.\nCopy \u0026amp; Paste Command yang diberikan oleh Rancher kesetiap Instances dan tunggu sekitar 10 sampai 15 menit agar Cluster benar-benar dapat digunakan, Rancher akan secara otomatis menyiapkan Kubernetes Cluster untuk anda. Selama Provisioning, memang ada logs error. Tapi jangan panik, memang di Rancher warnanya begini.\nJika Provisioning sudah, akan ada info bahwa status cluster adalah Active.\nNah itu tadi cara installasi High Availability (HA) Rancher menggunakan Docker. Kita akan eksplorasi lagi tentang Rancher selanjutnya, untuk sekarang saya sudahi dulu. Sekian dan terimakasih.\nReferensi  https://rancher.com/docs/rancher/v2.x/en  ","date":"2021-01-20T01:18:22+07:00","image":"https://blog.leonprasetya.my.id/p/high-availability-ha-rancher-installation-with-docker/index_hufaf80446c1310676cec50cf74fe7b4be_58769_120x120_fill_box_smart1_3.png","permalink":"https://blog.leonprasetya.my.id/p/high-availability-ha-rancher-installation-with-docker/","title":"High Availability (HA) Rancher Installation with Docker"},{"content":"Saya sudah berencana menulisnya sejak lama, namun saya sering lupa. Mumpung ingat saya akan bahas bagaimana saya melakukan setup untuk Kubernetes Cluster mulai dari provisioning server, pemilihan port, hingga kubernetes. Ini adalah artikel yang panjang, saya harap kalian tidak bosan membacanya. Jadi langsung saja kita mulai.\nStruktur Cluster Jadi disini saya ingin membuat total 3 server, 1 untuk server master dan 2 untuk server node.\nTerraform Pertama, untuk Provisioning server, saya sering menggunakan Terraform. Alat ini sangat cocok dan memang didesain untuk melakukan tugas penyiapan cloud server. Siapkan sebuah file berformat .tf. Untuk installasi Terraform sendiri bisa kalian cek disini. Dan mulailah menulis konfigurasi.\nKonfigurasi yang diperlukan Terraform : Berikut adalah susunan direktori kerja kita untuk terraform.\n1 2  ├── credentials └── server.tf   File Credentials (tidak perlu jika kalian sudah login menggunakan aws-cli). File ini berisi credentials yang diperlukan untuk login ke VPS kita. Normalnya kita menggunakan IAM (Identity and Access Management), namun karena kita menggunakan akun gratisan. Maka itu bisa didapatkan pada halaman Vocareum \u0026gt; Account Detail \u0026gt; Show AWS CLI, lalu copy semua ke dalam file credentials. Kelemahannya ini hanya berlaku sekitar 3 jam.\nDalam deskripsinya tertulis Copy and paste the following into ~/.aws/credentials. Namun jika memang tidak mau memasang aws-cli (seperti saya). Kita akan buat file credentials yang nantinya akan dipanggil didalam file konfigurasi terraform.\nFile Konfigurasi Server Disini kita baru mulai tahap provisioning instancenya. Untuk subnet yang saya gunakan adalah subnet default yang by default sudah ada di VPC saya dan untuk SSH Key saya juga sudah memilikinya sebelumnya.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191  ## AWS Provider terraform { required_providers { aws = { source = \u0026#34;hashicorp/aws\u0026#34; version = \u0026#34;~\u0026gt; 3.0\u0026#34; } } }## Init Credentials Profile and Region provider \u0026#34;aws\u0026#34; { profile = \u0026#34;default\u0026#34; region = \u0026#34;us-east-1\u0026#34; shared_credentials_file = \u0026#34;credentials\u0026#34; }## Public Security Group resource \u0026#34;aws_security_group\u0026#34; \u0026#34;public-sec\u0026#34; { name = \u0026#34;public\u0026#34; description = \u0026#34;Public Server Security Group\u0026#34;## SSH, HTTP, HTTPS Access  ingress { from_port = 22 to_port = 22 protocol = \u0026#34;tcp\u0026#34; cidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;] } ingress { from_port = 80 to_port = 80 protocol = \u0026#34;tcp\u0026#34; cidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;] } ingress { from_port = 443 to_port = 443 protocol = \u0026#34;tcp\u0026#34; cidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;] }## Kubernetes Cluster  ingress { from_port = 6443 to_port = 6443 protocol = \u0026#34;tcp\u0026#34; cidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;] } ingress { from_port = 2379 to_port = 2380 protocol = \u0026#34;tcp\u0026#34; cidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;] } ingress { from_port = 10250 to_port = 10250 protocol = \u0026#34;tcp\u0026#34; cidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;] } ingress { from_port = 10251 to_port = 10251 protocol = \u0026#34;tcp\u0026#34; cidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;] } ingress { from_port = 10252 to_port = 10252 protocol = \u0026#34;tcp\u0026#34; cidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;] } egress { from_port = 0 to_port = 0 protocol = \u0026#34;-1\u0026#34; cidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;] } tags = { Name = \u0026#34;public\u0026#34; Description = \u0026#34;Public Server Security Group\u0026#34; } }## Elastic IP for Public Instance resource \u0026#34;aws_eip\u0026#34; \u0026#34;lb\u0026#34; { instance = aws_instance.public.id }## Create Public Instance resource \u0026#34;aws_instance\u0026#34; \u0026#34;public\u0026#34; { ami = \u0026#34;ami-00ddb0e5626798373\u0026#34; instance_type = \u0026#34;t2.medium\u0026#34; source_dest_check = false key_name = \u0026#34;key\u0026#34; subnet_id = \u0026#34;subnet-5ba4f616\u0026#34; private_ip = \u0026#34;172.31.16.20\u0026#34; vpc_security_group_ids = aws_security_group.public-sec.*.id tags = { Name = \u0026#34;public\u0026#34; }## Disk Space  root_block_device { delete_on_termination = true encrypted = false iops = 100 volume_size = 10 } }## Node Security Group resource \u0026#34;aws_security_group\u0026#34; \u0026#34;node-sec\u0026#34; { name = \u0026#34;node\u0026#34; description = \u0026#34;Node/Worker Security Group\u0026#34;## SSH Access  ingress { from_port = 22 to_port = 22 protocol = \u0026#34;tcp\u0026#34;## Close all traffic IP after setup! #cidr_blocks = [\u0026#34;172.31.16.20/32\u0026#34;]  cidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;] }## Kubernetes Cluster  ingress { from_port = 10250 to_port = 10250 protocol = \u0026#34;tcp\u0026#34; cidr_blocks = [\u0026#34;172.31.16.20/32\u0026#34;] } ingress { from_port = 10255 to_port = 10255 protocol = \u0026#34;tcp\u0026#34; cidr_blocks = [\u0026#34;172.31.16.20/32\u0026#34;] } ingress { from_port = 30000 to_port = 32767 protocol = \u0026#34;tcp\u0026#34; cidr_blocks = [\u0026#34;172.31.16.20/32\u0026#34;] } ingress { from_port = 3000 to_port = 3000 protocol = \u0026#34;tcp\u0026#34; cidr_blocks = [\u0026#34;172.31.16.20/32\u0026#34;] } egress { from_port = 0 to_port = 0 protocol = \u0026#34;-1\u0026#34; cidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;] } tags = { Name = \u0026#34;node\u0026#34; Description = \u0026#34;Node/Worker Security Group\u0026#34; } }## Elastic IP for Node Server (Temporary) resource \u0026#34;aws_eip\u0026#34; \u0026#34;lb-node\u0026#34; { count = 2 instance = aws_instance.node[count.index].id }## Create Instance Node resource \u0026#34;aws_instance\u0026#34; \u0026#34;node\u0026#34; { ami = \u0026#34;ami-00ddb0e5626798373\u0026#34; instance_type = \u0026#34;t2.small\u0026#34; associate_public_ip_address = false source_dest_check = false key_name = \u0026#34;key\u0026#34; subnet_id = \u0026#34;subnet-5ba4f616\u0026#34; vpc_security_group_ids = aws_security_group.node-sec.*.id count = 2 tags = { Name = \u0026#34;node-${count.index + 1}\u0026#34; }## Disk Space  root_block_device { delete_on_termination = true encrypted = false iops = 100 volume_size = 10 } }   Setelah semuanya terkonfigurasi, informasi tentang kode sudah saya masukkan, untuk lebih lengkapnya bisa kalian baca sendiri pada Website Dokumentasi Terraform, jalankan perintah terraform init untuk inisialisasi version control Terraform dan Terraform juga mengunduh tools yang dibutuhkan untuk provisioning cloud server AWS. Setelah semuanya selesai jalankan perintah terraform apply.\nTulis yes untuk konfirmasi (jika konfigurasi sudah dirasa benar).\nCek pada EC2 AWS, server yang sudah kita buat tadi.\nNote : Untuk port kubernetes yang benar, kalian dapat melihatnya disini, tapi kalau cuma untuk testing All Traffic bukan masalah.\nAnsible Setelah semua instance sudah siap, kita akan melakukan konfigurasi instance menggunakan Ansible. Apa itu Ansible?? Jadi tool ini berguna untuk melakukan tugas-tugas yang berada dalam mesin seperti installasi paket, mengubah file konfigurasi, dll. Dia (Ansible) akan melakukan tugasnya secara struktural dan jika ada satu perintah diatasnya yang gagal, maka proses dibawahnya akan dibatalkan. Anyway\u0026hellip; Disini saya akan melakukan setup mulai dari akses SSH, installasi Docker dan Kubernetes Cluster (sebenarnya pada saat artikel ditulis, kubernetes sudah mengumumkan bahwa support pada Docker akan dihentikan, dan mungkin saat kalian membacanya, cara ini sudah tidak dapat digunakan. Pada saat itu saya akan mengupdate artikel ini.).\nJadi susunan filenya akan terlihat seperti berikut :\n1 2 3 4 5 6 7  ├── inventory ├── ansible.cfg ├── auth_aws.yml ├── docker.yml ├── k8s.yml ├── key └── key.pem   1. inventory Inventory berisi ip atau hostname dari instance yang akan ditargetkan untuk dikonfigurasikan (biasanya ip address). Oleh karena itu saya memasang elastic ip pada instance yang sudah saya buat, agar mereka bisa diakses oleh Ansible dan setelah proses konfigurasi EIP (Elastic IP) bisa dilepas.\n1 2 3 4 5 6 7  #ubah sesuai dengan IP address kalian [public] 52.4.21.127 [nodes] 35.173.95.146 18.205.203.199   2. ansible.cfg Disini kita bisa mengatur semua file yang dibutuhkan untuk menjalankan Ansible, seperti file inventory yang digunakan, keyfile, default user, dll.\n1 2 3 4 5 6  [defaults] inventory = inventory Private_key_file = key/key.pem remote_user = root ansible_python_interpreter = /usr/bin/python3 host_key_checking = false   3. File berekstensi *.yml File yang berisi konfigurasi seperti apa yang akan kita lakukan (like i said structural code). Kita harus mendikte apa saja yang kita perlukan untuk menyiapkan server (sampai jadi). Pesan dari saya : Kalau bingung lihat namenya saja ya\n3.1 auth_aws.yml Karena AWS tidak memperbolehkan user untuk login melalui root user (demi keamanan), maka kita harus merubah file authorized_key secara manual.\n1 2 3 4 5 6 7  - hosts:allbecome:truebecome_user:ubuntugather_facts:falsetasks:- name:Copy authorized key from Home to Rootshell:sudo cp /home/ubuntu/.ssh/authorized_keys /root/.ssh  3.2 docker.yml Installasi Docker. Disini saya menggunakan fitur hold, fungsinya untuk menghindari update pada package. Kenapa?? Jika kita melakukan setup pada server production, kita memerlukan versi package yang stabil, tujuannya untuk menghindari bug atau perubahan besar-besaran yang dapat menyebabkan server menjadi tidak stabil. Jadi biasanya untuk mencoba update kami memiliki server tersendiri untuk deployment test, jika pada test server sudah stabil, maka server production akan diupdate.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  - hosts:allgather_facts:falsetasks:- name:Update \u0026amp; Upgradeapt:upgrade:distupdate_cache:yes- name:Install Docker Requiremtsapt:name:- ca-certificates- curl- gnupg-agent- python3-pip- software-properties-common- name:GPG Key Dockerapt_key:url:https://download.docker.com/linux/ubuntu/gpg- name:Repo Dockerapt_repository:repo:deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stablestate:presentupdate_cache:yes- name:Install Dockerapt:force:Truename:- docker-ce- name:Hold Dockerdpkg_selections:name:docker-ceselection:hold- name:Install Docker Pycommand:pip3 install docker-py- name:Enable service docker, and enable persistentlyservice:name:dockerenabled:yes- name:Add the user \u0026#39;ubuntu\u0026#39; to docker groupuser:name:ubuntugroup:docker  3.3 k8s.yml Akhirnya installasi Kubernetes. Disini saya juga menggunakan fitur hold. Sayang untuk kubeadm (inisialisasi node) saya masih menggunakan cara manual, jadi jika teman-teman memiliki cara yang lebih baik saya akan dengan senang hati menerima saran tersebut.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91  - hosts:allgather_facts:falsetasks:- name:Add Google official GPG keyapt_key:url:https://packages.cloud.google.com/apt/doc/apt-key.gpgstate:present- name:Add Kubernetes Repositoryapt_repository:repo:deb http://apt.kubernetes.io/ kubernetes-xenial mainstate:presentfilename:kubernetesmode:0600- name:Installing Kubernetes Cluster Packagesapt:force:Truename:- kubeadm- kubectl- kubeletstate:present- name:Hold kubeadmdpkg_selections:name:kubeadmselection:hold- name:Hold kubectldpkg_selections:name:kubectlselection:hold- name:Hold kubeletdpkg_selections:name:kubeletselection:hold- name:Add line Net Bridge on sysctl.conflineinfile:path:/etc/sysctl.confline:net.bridge.bridge-nf-call-iptables=1- name:Add line \u0026#39;max_map_count\u0026#39; on sysctl.conflineinfile:path:/etc/sysctl.confline:vm.max_map_count=262144- name:Apply change on sysctlshell:sysctl -p- hosts:publicgather_facts:falsetasks:- name:initialize k8s clustershell:kubeadm reset -f \u0026amp;\u0026amp; kubeadm init --pod-network-cidr=10.244.0.0/16register:kubeadm_result- debug:var:kubeadm_result.stdout_lines- name:Make configuration folder for k8sbecome:yesbecome_user:ubuntufile:state:directorypath:/home/ubuntu/.kubemode:0755- name:Copy configuration k8s into homecopy:src:/etc/kubernetes/admin.confdest:/home/ubuntu/.kube/configremote_src:yesowner:ubuntu- name:apply network plugin flannelbecome:yesbecome_user:ubuntushell:kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml- hosts:nodesgather_facts:falsevars_prompt:- name:\u0026#34;kubeadm\u0026#34;prompt:\u0026#34;kubeadm Command \u0026#34;private:notasks:- name:Reset kubeadm \u0026amp; Prune docker imagesshell:kubeadm reset -f \u0026amp;\u0026amp; docker image prune -af- name:Retriving input command kubeadmshell:\u0026#34;{{ kubeadm }}\u0026#34;  Jalankan ketiga file ini dengan perintah ansible-playbook nama_file.yml. Untuk k8s.yml, ditengah jalan nanti akan ditanyakan tentang token kubeadm seperti pada GIF dibawah, kalian copy saja log diatasnya jangan lupa tambahkan sudo.\nTesting Masuk ke server utama (public) kita melalui SSH.\n1  ssh ubuntu@52.4.21.127 -i key.pem   Lalu jalankan perintah kubectl get all atau kubectl get nodes.\nJika semuanya sudah tampil, kita bisa melakukan deployment pods pada cluster kubernetes tersebut. Namun saya tidak akan membahasnya pada artikel ini.\nHapus EIP dan associate_public_ip_address Delete atau beri comment pada file server.tf pada baris EIP.\n1 2 3 4 5  ## Elastic IP for Node Server (Temporary) #resource \u0026#34;aws_eip\u0026#34; \u0026#34;lb-node\u0026#34; { # count = 2 # instance = aws_instance.node[count.index].id #}   Kenapa saya menghapus associate_public_ip_address? Biasanya perintah ini akan memaksa kita untuk me-recreate server. Ini pasti menyebalkan apalagi kita sudah susah-susah setup server sedemikian rupa dengan Ansible. Disatu sisi kita juga membutuhkan fitur ini saat pembuatan server untuk pertama kali. Jadi kalau server sudah dibuat, kita sudah tidak menggunakannya lagi.\n1  # associate_public_ip_address = false   Jalankan perintah terraform apply sekali lagi.\nDestroy Semua Server Kalau kalian bosan, coba jalankan perintah terraform destroy!\nPenutup Dan begitulah cara saya melakukan setup server mulai dari provisioning server, konfigurasi dan membangun kubernetes cluster. Jika ada pertanyaan dan saran, silahkan dikumpulkan dikolom komentar. Selanjutnya saya akan membahas tentang Rancher. Sekian dan terimakasih\n","date":"2021-01-12T22:34:00+07:00","image":"https://blog.leonprasetya.my.id/p/setup-kubernetes-cluster-pada-aws-educate-mulai-dari-penyiapan-server-sampai-selesai/index_hud58fbdd7d7f06b1214dd0bfd7cea0c2d_145250_120x120_fill_box_smart1_3.png","permalink":"https://blog.leonprasetya.my.id/p/setup-kubernetes-cluster-pada-aws-educate-mulai-dari-penyiapan-server-sampai-selesai/","title":"Setup Kubernetes Cluster pada AWS Educate Mulai Dari Penyiapan Server Sampai Selesai"},{"content":"Intro Kadang dilingkungan pekerjaan atau perkuliahan, kita sering mendengar tentang Agile dan DevOps namun kita tidak tau apa fungsi mereka. Jadi Agile dan DevOps adalah metodologi pengembangan aplikasi dengan tujuan yang sama yaitu mereka menghasilkan produk akhir secepat dan seefisien mungkin. Awalnya saya mengira dua metodologi ini adalah satu kesatuan, namun setelah saya selidiki dan membaca lebih dalam ternyata mereka berbeda. Apa saja perbedaannya? Dan apakah mereka bisa digunakan dalam satu proses yang sama? Mari kita bahas terlebih dahulu apa itu Agile dan DevOps.\nAgile Jadi Agile Development ini pertama kali dicetuskan oleh Kent Beck dan kawan-kawan pada tahun 2001. Mereka mendiskusikan tentang bagaimana cara mengembangkan sebuah perangkat lunak menjadi lebih baik, efisien dan cepat. Metode Agile mengutamakan interaksi antar tim pengembang dan review/tanggapan dari client walaupun itu dapat menyebabkan keterlambatan dalam proses pengembangan, tapi dari tim development tetap mengutamakan kecepatan dalam bekerja, itulah mengapa Agile lebih sering saya sebut sebagai semangat bekerja. Jadi dari sana pihak pengembang dan client saling terhubung untuk menciptakan suatu perangkat lunak.\nBisa kalian cek pada webiste https://agilemanifesto.org untuk manifesto dari Agile.\nSaat belajar tentang Agile, kita akan menemukan proses tools pembantu seperti Scrum, Extreme Programming, dan Adaptive Software Development mereka biasanya dibundle menjadi 1 paket aplikasi, sebagai contoh yaitu Jira Software. Itu adalah contoh proses yang menerjemahkan nilai dan prinsip Agile dalam praktik. Selain itu, ada metode yang populer di dunia Agile seperti user story, story point, burndown chart, daily meeting, dan retrospective. Masing-masing proses dan metode memenuhi nilai dan prinsip Agile dengan kedalaman yang berbeda-beda.\nDevOps Sedangkan untuk DevOps yaitu metodologi pengembangan perangkat lunak yang bertujuan untuk menyatukan tim pengembangan perangkat lunak dan tim teknologi informasi. Ini adalah konsep yang menumbuhkan budaya kolaborasi antara kedua tim yang sebelumnya bekerja secara terpisah, dari tahap desain awal hingga rilis sebuah produk.\nDevOps adalah metodologi yang menggabungkan pengembangan perangkat lunak (Dev) dengan operasional (Ops). Tujuannya adalah untuk memungkinkan komunikasi antara tim sehingga mereka dapat membangun, menguji, dan merilis perangkat lunak lebih cepat dan dengan efisiensi dan kecepatan yang lebih besar.\nDalam menggabungkan dua tim dengan proses yang berbeda ini diharapkan memberikan produk dan layanan yang berkualitas tinggi secara berkesinambungan melalui integrasi berkelanjutan, distribusi berkelanjutan, pengujian seacara otomatis, dan transparansi dalam repositori kode.\nAlur DevOps berbeda dengan Agile, disini tidak ada kontak dari client. Pengembang akan merencanakan seperti apa perangkat lunaknya berjalan, setelah itu mereka akan melakukan serangkaian proses seperti Build, Test, Release, Deploy dan Monitoring, dari data monitoring tersebut jika ada kesalahan atau ketidak sesuaian dari perangkat lunak, pengembang akan mengulangi prosesnya dari awal (tahap perencanaan).\nJadi apa bedanya Agile dengan DevOps?  Agile menggunakan sprint, yang berkisar dari satu minggu hingga bulan sebagai cara untuk mengatur jadwal pengembangan sementara DevOps fokus pada rilis cepat yang dimulai dengan beberapa hari. Agile berfokus pada feedback dari client sedangkan DevOps tidak.  Apakah Agile dan DevOps dapat bekerja bersama? Jika ditanya begitu, jawabannya Kenapa tidak?\u0026hellip; Ketika diterapkan bersama-sama, Agile dan DevOps dapat memungkinkan organisasi untuk mengembangkan dan mengimplementasikan teknologi dengan kecepatan yang jauh lebih besar. Ada penekanan pada menempatkan kebutuhan pelanggan/client berada di garis depan diatas teknologi apa pun yang akan dikembangkan.\nAgile dan DevOps masing-masing merujuk pada dua hal berbeda, terkadang beberapa organisasi menggunakan satu metodologi untuk mengaktifkan yang lain misalnya menggunakan metodologi Agile sebagai motivator untuk mengembangkan culture DevOps.\nSumber  Pengalaman Pribadi https://medium.com/@ardi.alhaidar/apa-itu-agile-sebenarnya-41a14762b4e4 https://id.wikipedia.org/wiki/Agile_Development_Methods https://en.wikipedia.org/wiki/DevOps  Foot note Maaf jika penjelasannya agak berbelit belit. Jika ada kekurangan dan kesalahan jangan sungkan untuk mengkoreksi penulis (saya)\u0026hellip;Sekian dari saya semoga dapat mencerahkan kalian (para pembaca)\u0026hellip;\n","date":"2020-12-22T09:34:23+07:00","image":"https://blog.leonprasetya.my.id/p/perbedaan-antara-devops-dan-agile/index_hu6620c7cc13a868051b41a21af30829cf_279528_120x120_fill_box_smart1_3.png","permalink":"https://blog.leonprasetya.my.id/p/perbedaan-antara-devops-dan-agile/","title":"Perbedaan antara Devops dan Agile"},{"content":" UPDATE\n Sekarang sudah tidak bisa menggunakan cara ini..!!! Dan biasanya, tutorial kayak gini sering disalah gunakan Direkomendasikan untuk menggunakan AWS Free Tier   Hari ini saya akan bahas tentang AWS Server namun ini lebih ke pembuatan akunnya. Jadi AWS memang menyediakan layanan gratis untuk edukasi yang bernama AWS Educate. Disana, kita bisa mendapatkan akun AWS dengan credit senilai $100 dengan durasi 1 tahun. Nah ini cocok sekali untuk kalian yang ingin belajar DevOps/Infra (yang penting jangan buat minning 😂). Tentu saja blog ini akan terus membahas tentang cloud services, jadi akun AWS ini akan sangat membantu kalian dalam proses belajar.\nBuat akun AWS Educate dulu. Pergi ke halaman AWS Educate, lalu klik menu Join AWS Educate. Pilih role sebagai Murid/Student (Tergantung kebutuhan sih\u0026hellip; Kalau disini saya memang sebagai murid). Lalu tolong isi form yang diberikan dengan benar. Karena email akan digunakan untuk konfirmasi nantinya. Kalau sekolah kalian tidak ada didalam list, cantumkan saja Kementerian Pendidikan dan Kebudayaan atau Kementerian Komunikasi dan Informatika. Pastikan juga kalian memilih bulan dan tahun kelulusan (Graduation Month \u0026amp; Graduation Year) setahun dari sekarang, misal sekarang Desember 2020 pilih tanggal kelulusannya Desember 2021. Kira-kira tampilan akhirnya seperti ini. Dah selanjutnya tinggal klik I Agree saja. Setelah pendaftaran selesai, maka kita akan mendapatkan email verifikasi dari AWS. Setelah email sudah dikonfirmasi, saatnya menunggu email balasan dari AWS. Jika diterima seperti ini balasannya. Sekarang coba login ke AWS Educate. Lalu pergi ke tab AWS Account. Klik AWS Educate Starter Account. Nanti kita akan dialihkan ke website pihak ke-3. Disana kelihatan credits kalian tinggal berapa. Nice kita sudah masuk pada page EC2 Management. Namun untuk praktek penggunaan EC2 ini tidak akan saya bahas sekarang. Yeah\u0026hellip; Met belajar cuyy!!!\nNantikan artikel berikutnya tentang penggunaan AWS Cloud. Sampai jumpa\u0026hellip;!!!\n","date":"2020-12-20T19:34:30+07:00","permalink":"https://blog.leonprasetya.my.id/p/cara-membuat-akun-aws-educate-100-gratis/","title":"Cara membuat akun AWS Educate $100 Gratis"},{"content":"Intro Karena di Grup Facebook Lokal banyak yang tanya tentang bagaimana cara saya melakukan Kostumisasi pada Firefox, maka saya buatlah tutorial ini.\nRequirements  Mozila Firefox Skill CSS Dasar (Copy Paste juga boleh)  Tutorial Pertama, kita masuk dulu ke menu config, buka melalui search bar dengan mengetikkan about:config. Klik Accept the Risk and Continue.\nKedua, cari toolkit.legacyUserProfileCustomizations.stylesheets. Lalu ubah valuenya dari False menjadi True.\nLangkah selanjutnya yaitu membuat/menyunting file userChrome.css. Cara mengetahui direktori penyimpanan file confignya yaitu : Pergi ke Menu Help \u0026gt; Troubleshooting Information.\nCari menggunakan fitur search (Ctrl+F) dengan query Profile Directory, lalu klik Open Directory.\nMaka terbukalah directory konfigurasinya, disini cari directory chrome (jika tidak ada buatlah directorynya).\nSetelah kalian menemukan/membuat directory chrome, buat/edit file yang bernamakan userChrome.css.\nIsi settingnya sesuai kebutuhan kalian. Untuk yang saya gunakan, saya hanya menyembunyikan Navbar mozilla seperti gambar GIF dibawah.\nKalau kalian mau mencoba yang seperti itu, kalian bisa menggunakan config saya dibawah.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @-moz-document url(chrome://browser/content/browser.xul), url(chrome://browser/content/browser.xhtml) { #TabsToolbar \u0026gt; * { visibility: collapse; } #main-window:not([customizing]) #navigator-toolbox:not(:focus-within):not(:hover) { margin-top: -92px; } #navigator-toolbox { transition: 0.2s margin-top ease-out; } #sidebar-box[sidebarcommand=\u0026#34;treestyletab_piro_sakura_ne_jp-sidebar-action\u0026#34;] #sidebar-header { display: none; } }   Save file, lalu restart firefox.\nSemoga tutorial ini bermanfaat. Sekian dan Terimakasih\n","date":"2020-04-30T23:39:39+07:00","permalink":"https://blog.leonprasetya.my.id/p/kostumisasi-mozila-firefox-dengan-mengubah-userchrome.css/","title":"Kostumisasi Mozila Firefox dengan mengubah userChrome.css"},{"content":"Sebelumnya saya telah membuat tutorial How I Made Hugo Blog. Ini lanjutan yang telah saya janjikan. Dan maaf saya sekarang pakai Bahasa Indonesia, karena ternyata setelah saya membuat postingan tersebut ternyata Bahasa Inggris saya masih kacau dan terlihat di postingan sebelumnya bahasanya kacau sekali (jadi malu). Yah tidak usah basa-basi lagi.\nTutorial 1. Generate Static Files Jika sebelumnya kita hanya menjalankan server local dengan perintah hugo server. Sekarang kita akan meng-generate file statis dengan perintah hugo --minify. Perintah tersebut akan menjadikan tulisan dan tema yang kalian buat menjadi file statis yang bisa kalian temui di folder public.\n2. Buat Repo Github Kita pakai cara mudah saja. Yaitu, pada browser kita buat repo di Github. Nama repo terserah kalian, buat tanpa README.\nSetelah repo dibuat, disana terdapat tutorialnya tentang cara membuat repository di command line kalian.\nLangsung buka terminal, masuk ke folder blog kalian dan langsung menuju folder public\n1  cd blog/public   Lalu inisiasi repo github yang telah dibuat tadi.\n1 2 3 4 5 6  git init git commit -m \u0026#34;first commit blog\u0026#34; git remote add origin https://github.com/\u0026lt;your_username\u0026gt;/nama_repo.git git push -u origin master # ganti username dan nama_repo dengan milik kalian masing-masing   Setelah proses push berhasil, kembali buka browser kalian, lalu menuju Setting repository kalian. Scroll kebawah sampai menemukan tulisan Github Pages. Klik pada menu dropdown None. Lalu kill branch yang kalian inginkan, dalam case ini, tadi kita pakai master branch. Jadi klik itu saja (seperti gambar dibawah).\nDan website kalian sudah mengudara di internet.\nKarena blog ini berfokus pada DevOps, tidak enak rasanya jika harus melakukan perintah berulang-ulang setiap akan melakukan post artikel baru. Selanjutnya saya akan membahas tentang CI/CD pada Github Actions untuk hosting Hugo\u0026hellip;\n","date":"2020-04-29T00:16:59+07:00","image":"https://blog.leonprasetya.my.id/p/host-website-hugo-di-github/hugo_huf7630602c9bedf706ad0ded87d4ffc01_56751_120x120_fill_box_smart1_3.png","permalink":"https://blog.leonprasetya.my.id/p/host-website-hugo-di-github/","title":"Host Website Hugo di Github"},{"content":"Intro Hey guys, i’ll teach you how to made blog with hugo. First i’ll explain a bit about hugo, Hugo is a fast and modern static site generator written in Go language, so basically you don’t need some back-end code. You just install it, made a content, then generate your html code. Simple enought right. So let’s jump to tutorial.\nSpecification and requirements First, i use Arch Linux Distros, the installation maybe a bit differ, but others absolutelly same. Make sure your repository always up to date.\n1  sudo pacman -Syu hugo   If you use other distros, you can check a link here Hugo Installation Guide\nTutorial Okay.. i assume you’re already install Hugo, once Hugo installed, you can create a Hugo sites by running.\n1 2 3  hugo new site blog #replace blog with the name you want   Then go to your site directory.\n1  cd blog   So… Next we need template. Find one at Official Hugo Website Here. There are many choices, choose the one you like. For example i choose Hugo.386. Download theme using git.\n1  git submodule add https://gitlab.com/maxlefou/hugo.386 themes/hugo.386   If you facing error like this.\n1  fatal: not a git repository (or any of the parent directories): .git   Try git init to your main folder. Then run command git submodule again.\nThen go to themes/hugo.386/exampleSite. There are examples that you can use.\nCopy all (except README.md). To your main directory. Like this.\nOpen config.toml. Edit everything you need, if there is anything you don’t need, just mark it with #. The following example.\n1 2 3 4 5 6 7  baseurl = \u0026#34;/\u0026#34; title = \u0026#34;ledleledle\u0026#39;s Blog\u0026#34; #languageCode = \u0026#34;en\u0026#34; #DefaultContentLanguage = \u0026#34;en\u0026#34; preserveTaxonomyNames = true theme = \u0026#34;hugo.386\u0026#34; ...   You can freely customize the information in config.toml files. If you done, lets test the site by running this command.\n1  hugo serve   Open http://localhost:1313 in your browser.\nTo add new content in your blog, simply running this command.\n1  hugo new post/new_article.md   Fill the content as you like, see an example of the writing on content folder that you copied before. Next. I’ll post tutorial to host it on Github Page.\nOutro Well thats it… If you’re facing a problem comments down bellow. See you in next tutorial.\n","date":"2020-04-24T00:16:59+07:00","image":"https://blog.leonprasetya.my.id/p/how-i-made-hugo-blog/hugo_huf7630602c9bedf706ad0ded87d4ffc01_56751_120x120_fill_box_smart1_3.png","permalink":"https://blog.leonprasetya.my.id/p/how-i-made-hugo-blog/","title":"How I Made Hugo Blog"},{"content":"Halo teman-teman, kali ini saya akan membahas tentang bagaimana cara reflash original firmware dari OpenWRT pada router TP-Link MR3420 V.2. Kebetulan diminggu-minggu ini saya ingin menjual router saya karena menurut saya router ini sudah outdate dan dirumah juga sudah punya yang baru.\nSpesifikasi dan Kebutuhan  Router (sudah pasti) OS Linux Firmware bawaan TP-Link disini  Tutorial Step pertama, ekstrak file firmware terlebih dahulu\n1  unzip \u0026#34;TL-MR3420_V2_150319.zip\u0026#34;   Rename file firmware dengan nama firmware.bin agar dalam pengerjaannya jadi lebih mudah dan simple.\n1  mv \u0026#34;mr3420v2_en_3_16_9_up_boot(150319).bin\u0026#34; firmware.bin   Hapus beberapa byte dari Firmware dengan perintah dd. Bila perintah ini tidak dijalankan maka hasilnya anda akan mendapatkan pesan error Writing from /tmp/firmware.bin to firmware … [e]Failed to erase block saat proses flashing firmware.\n1 2 3 4 5 6 7  #command dd if=firmware.bin of=original.bin skip=257 bs=512 #log 7680+0 records in 7680+0 records out 3932160 bytes (3.9 MB, 3.8 MiB) copied, 0.0352155 s, 208 MB/s   Upload Firmware ke router kalian dengan perintah scp\n1  scp original.bin root@4.3.2.1:/tmp    Q : Kok ipnya 4.3.2.1? A : Iya itu setting ip router saya sebelumnya.  Masuk ke sistem router melalui ssh dengan perintah\n1  ssh root@4.3.2.1    Note : inget ya, sesuaikan dengan ip router kalian masing-masing.\n Install firmware original TP-Link 1 2 3 4 5 6 7 8  #command mtd -r write /tmp/original.bin firmware #log Unlocking firmware ... Writing from /tmp/original.bin to firmware ... Rebooting ...   Setelah proses selesai, router akan restart dengan sendirinya.\nBagaimana tutorialnya? mudah bukan, semoga bermanfaat untuk kalian, sekian dari saya terimakasih.\n","date":"2020-04-24T00:16:59+07:00","image":"https://blog.leonprasetya.my.id/p/reflash-original-firmware-tp-link-mr3420-v.2/index_hu4a37e72759dcf23e0c2bbe493cab5a41_29892_120x120_fill_box_smart1_3.png","permalink":"https://blog.leonprasetya.my.id/p/reflash-original-firmware-tp-link-mr3420-v.2/","title":"Reflash Original Firmware TP-Link MR3420 V.2"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike1 Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code    Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10  \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10  \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","date":"2019-03-11T00:00:00Z","image":"https://blog.leonprasetya.my.id/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.leonprasetya.my.id/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"}]